---
title: "4-Descriptive Analyses"
format: gfm
---


```{r, setup, include=FALSE}
knitr::opts_chunk$set(paged.print = FALSE)
```


# Setup

Reference prior chapter

```{r}
#| message: false
library(tidyverse)
library(srvyr)
library(broom)
load("data/anes_2020.rda")
load("data/recs_2020.rda")
```

```{r}
target_pop <- 231592693

anes_des <- anes_2020 %>%
  mutate(weight = sum(Weight) * target_pop) %>%
  as_survey_design(
    weights = weight,
    strata = Stratum,
    ids = VarUnit,
    nest = T
  )
```

```{r}
recs_des <- recs_2020 %>%
  as_survey_rep(
    weights = NWEIGHT,
    repweights = NWEIGHT1:NWEIGHT60,
    type = "JK1",
    scale = 59 / 60,
    mse = T
  )
```

# Intro

This chapter discusses how to analyze measures of distribution (e.g., cross-tabulations), central tendency (e.g., means), relationship (e.g., ratios), and dispersion (e.g., standard deviation) using functions from the {srvyr} package (Freedman Ellis and Schneider 2024).

Measures of distribution describe how often an event or response occurs. These measures include counts and totals. We cover the following functions:

- Count of observations (survey_count() and survey_tally())
- Summation of variables (survey_total())

Measures of central tendency find the central (or average) responses. These measures include means and medians. We cover the following functions:

- Means and proportions (survey_mean() and survey_prop())
- Quantiles and medians (survey_quantile() and survey_median())

Measures of relationship describe how variables relate to each other. These measures include correlations and ratios. We cover the following functions:

- Correlations (survey_corr())
- Ratios (survey_ratio())

Measures of dispersion describe how data spread around the central tendency for continuous variables. These measures include standard deviations and variances. We cover the following functions:

- Variances and standard deviations (survey_var() and survey_sd())

# Counts and Cross-tabulations

```
survey_count(
  x,
  ...,
  wt = NULL,
  sort = FALSE,
  name = "n",
  .drop = dplyr::group_by_drop_default(x),
  vartype = c("se", "ci", "var", "cv")
  )
```


- x: a tbl_svy object created by as_survey
- ...: variables to group by, passed to group_by
- wt: a variable to weight on in addition to the survey weights, defaults to NULL
- sort: how to sort the variables, defaults to FALSE
- name: the name of the count variable, defaults to n
- .drop: whether to drop empty groups
- vartype: type(s) of variation estimate to calculate including any of c("se", "ci", "var", "cv"), defaults to se (standard error)

```
survey_tally(
  x,
  wt,
  sort = FALSE,
  name = "n",
  vartype = c("se", "ci", "var", "cv")
)
```
Both functions include the vartype argument with four different values:

- se: standard error
  - The estimated standard deviation of the estimate
  - Output has a column with the variable name specified in the name argument with a suffix of “_se”
- ci: confidence interval
  - The lower and upper limits of a confidence interval
  - Output has two columns with the variable name specified in the name argument with a suffix of “_low” and “_upp”
  - By default, this is a 95% confidence interval but can be changed by using the argument level and specifying a number between 0 and 1. For example, level=0.8 would produce an 80% confidence interval.
- var: variance
  - The estimated variance of the estimate
  - Output has a column with the variable name specified in the name argument with a suffix of “_var”
- cv: coefficient of variation
  - A ratio of the standard error and the estimate
  - Output has a column with the variable name specified in the name argument with a suffix of “_cv”
  
  
Note that specifying df = Inf is equivalent to using a normal (z-based) confidence interval – this is the default in {survey}.


## Estimated Population Count

```{r}
recs_des %>%
  survey_count()
recs_des %>%
  survey_tally()
```

## Estimated counts by subgroups (cross-tabs)

```{r}
recs_des %>%
  survey_count(Region, Division, name = "N") # Changes count variable name
```

Or

```{r}
recs_des %>%
  group_by(Region, Division) %>%
  survey_tally(name = "N")
```

# Totals and Sums

```
survey_total(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  deff = FALSE,
  df = NULL
)
```

- x: a variable, expression, or empty
- na.rm: an indicator of whether missing values should be dropped, defaults to FALSE
- vartype: type(s) of variation estimate to calculate including any of c("se", "ci", "var", "cv"), defaults to se (standard error) (see Section 5.2.1 for more information)
- level: a number or a vector indicating the confidence level, defaults to 0.95
- deff: a logical value stating whether the design effect should be returned, defaults to FALSE (this is described in more detail in Section 5.9.3)
- df: (for vartype = 'ci'), a numeric value indicating degrees of freedom for the t-distribution

## Estimated Population Count

```{r}
recs_des %>%
  summarize(tot = survey_total())
```

## Overall summation of continuous variables

```{r}
recs_des %>%
  summarise(elec_bill = survey_total(DOLLAREL))
```

It is estimated that American residential households spent a total of \$170,473,527,909 on electricity in 2020, and the estimate has a standard error of \$664,893,504.

## Summation by groups

```{r}
recs_des %>%
  group_by(Region) %>%
  summarise(elec_bill = survey_total(DOLLAREL, vartype = "ci"))
```

# Means and Proportions

```
survey_mean(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  proportion = FALSE,
  prop_method = c("logit", "likelihood", "asin", "beta", "mean"),
  deff = FALSE,
  df = NULL
)

survey_prop(
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  proportion = TRUE,
  prop_method = 
    c("logit", "likelihood", "asin", "beta", "mean", "xlogit"),
  deff = FALSE,
  df = NULL
)
```

- na.rm: an indicator of whether missing values should be dropped, defaults to FALSE
- vartype: type(s) of variation estimate to calculate including any of c("se", "ci", "var", "cv"), defaults to se (standard error) (see Section 5.2.1 for more information)
- level: a number or a vector indicating the confidence level, defaults to 0.95
- prop_method: Method to calculate the confidence interval for confidence intervals
- deff: a logical value stating whether the design effect should be returned, defaults to FALSE (this is described in more detail in Section 5.9.3)
- df: (for vartype = 'ci'), a numeric value indicating degrees of freedom for the t-distribution

The confidence interval used for most measures, such as means and counts, is referred to as a Wald-type interval. However, for proportions, a Wald-type interval with a symmetric t-based confidence interval may not provide accurate coverage, especially when dealing with small sample sizes or proportions “near” 0 or 1. We can use other methods to calculate confidence intervals, which we specify using the prop_method option in survey_prop(). The options include:

- logit: fits a logistic regression model and computes a Wald-type interval on the log-odds scale, which is then transformed to the probability scale. This is the default method.
- likelihood: uses the (Rao-Scott) scaled chi-squared distribution for the log-likelihood from a binomial distribution.
- asin: uses the variance-stabilizing transformation for the binomial distribution, the arcsine square root, and then back-transforms the interval to the probability scale.
- beta: uses the incomplete beta function with an effective sample size based on the estimated variance of the proportion.
- mean: the Wald-type interval ($\pm t^∗_{df}×SE$).
- xlogit: uses a logit transformation of the proportion, calculates a Wald-type interval, and then back-transforms to the probability scale. This method is the same as those used by default in SUDAAN and SPSS.

## One variable proportion

Proportion of people in each region.

```{r}
#| warning: false
recs_des %>%
  group_by(Region) %>%
  summarize(p = survey_prop())
```

```{r}
recs_des %>%
  group_by(Region) %>%
  summarize(p = survey_mean())
```

The `survey_prop()` function is essentially the same as using `survey_mean()` with a categorical variable and without specifying a numeric variable in the x argument. 

## Conditional Proportions

```{r}
recs_des %>%
  group_by(Region, ACUsed) %>%
  summarize(p = survey_prop())
```

## Joint Proportions

```{r}
recs_des %>%
  group_by(interact(Region, ACUsed)) %>%
  summarize(p = survey_prop())
```

## Overall Mean

```{r}
recs_des %>%
  summarise(elec_bill = survey_mean(
    DOLLAREL,
    vartype = c("se", "ci")
  ))
```

## Means by subgroup

```{r}
recs_des %>%
  group_by(Region) %>%
  summarize(elec_bill = survey_mean(DOLLAREL))
```

# Quantiles and Medians

```
survey_quantile(
  x,
  quantiles,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  interval_type = 
    c("mean", "beta", "xlogit", "asin", "score", "quantile"),
  qrule = c("math", "school", "shahvaish", "hf1", "hf2", "hf3", 
            "hf4", "hf5", "hf6", "hf7", "hf8", "hf9"),
  df = NULL
)

survey_median(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  interval_type = 
    c("mean", "beta", "xlogit", "asin", "score", "quantile"),
  qrule = c("math", "school", "shahvaish", "hf1", "hf2", "hf3", 
            "hf4", "hf5", "hf6", "hf7", "hf8", "hf9"),
  df = NULL
)
```

The arguments available in both functions are:

- x: a variable, expression, or empty
- na.rm: an indicator of whether missing values should be dropped, defaults to FALSE
- vartype: type(s) of variation estimate to calculate, defaults to se (standard error)
- level: a number or a vector indicating the confidence level, defaults to 0.95
- interval_type: method for calculating a confidence interval
- qrule: rule for defining quantiles. The default is the lower end of the quantile interval (“math”). The midpoint of the quantile interval is the “school” rule. “hf1” to “hf9” are weighted analogs to type=1 to 9 in quantile(). “shahvaish” corresponds to a rule proposed by Shah and Vaish (2006). See vignette("qrule", package="survey") for more information.
- df: (for vartype = 'ci'), a numeric value indicating degrees of freedom for the t-distribution

Quantiles also have two more methods available:

- score: the Francisco and Fuller confidence interval based on inverting a score test (only available for design-based survey objects and not replicate-based objects)
- quantile: based on the replicates of the quantile. This is not valid for jackknife-type replicates but is available for bootstrap and BRR replicates.

## Overall Quartiles

```{r}
recs_des %>%
  summarise(
    elec_bill = survey_quantile(DOLLAREL,
      quantiles = c(0.25, 0.5, 0.75)
    )
  )
```

## Quartiles by Subgroup

```{r}
recs_des %>%
  group_by(Region) %>%
  summarise(elec_bill = survey_quantile(DOLLAREL,
    quantiles = c(0.25, .5, .75)
  ))
```

## Minimum and Maximum

```{r}
recs_des %>%
  summarize(elec_bill = survey_quantile(DOLLAREL,
    quantiles = c(0, 1)
  ))
```

Some customers sell energy back to the grid, hence the negative number.

## Overall Median

```{r}
recs_des %>%
  summarize(elec_bill = survey_median(DOLLAREL))
```

## Medians by Subgroup

```{r}
recs_des %>%
  group_by(Region) %>%
  summarize(elec_bill = survey_median(DOLLAREL))
```

# Ratios

```
survey_ratio(
  numerator,
  denominator,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  deff = FALSE,
  df = NULL
)
```


- numerator: The numerator of the ratio
- denominator: The denominator of the ratio
- na.rm: A logical value to indicate whether missing values should be dropped
- vartype: type(s) of variation estimate to calculate including any of c("se", "ci", "var", "cv"), defaults to se (standard error) (see Section 5.2.1 for more information)
- level: A single number or vector of numbers indicating the confidence level
- deff: A logical value to indicate whether the design effect should be returned (this is described in more detail in Section 5.9.3)
- df: (For vartype = “ci” only) A numeric value indicating the degrees of freedom for t-distribution

## Overall Ratios

Suppose we wanted to find the ratio of dollars spent on liquid propane per unit (in British thermal unit [Btu]) nationally6. To find the average cost to a household, we can use survey_mean(). However, to find the national unit rate, we can use survey_ratio(). I

```{r}
recs_des %>%
  summarize(
    DOLLARLP_Tot = survey_total(DOLLARLP, vartype = NULL),
    BTULP_Tot = survey_total(BTULP, vartype = NULL),
    DOL_BTU_Rat = survey_ratio(DOLLARLP, BTULP),
    DOL_BTU_Avg = survey_mean(DOLLARLP / BTULP, na.rm = T)
  )
```

## Ratios by Subgroup

```{r}
recs_des %>%
  group_by(Region) %>%
  summarize(DOL_BTU_Rat = survey_ratio(DOLLARLP, BTULP)) %>%
  arrange(DOL_BTU_Rat)
```

# Correlations

```
survey_corr(
  x,
  y,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  df = NULL
)
```

- level: (For vartype = “ci” only) A single number or vector of numbers indicating the confidence level
- df: (For vartype = “ci” only) A numeric value indicating the degrees of freedom for t-distribution

## Overall Correlation

```{r}
#| warning: false
recs_des %>%
  summarize(SQFT_Elec_Corr = survey_corr(TOTSQFT_EN, BTUEL))
```

## Correlation by Subgroup

```{r}
#| warning: false
recs_des %>%
  group_by(ACUsed) %>%
  summarize(SQFT_Elec_Corr = survey_corr(TOTSQFT_EN, DOLLAREL))
```

# Standard Deviation and Variance

```
survey_var(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci", "var"),
  level = 0.95,
  df = NULL
)

survey_sd(
  x, 
  na.rm = FALSE
)
```

## Overall Variability

```{r}
#| warning: false
recs_des %>%
  summarize(
    var_elbill = survey_var(DOLLAREL),
    sd_elbill = survey_sd(DOLLAREL)
  )
```

## Variability by Subgroup

```{r}
#| warning: false
recs_des %>%
  group_by(Region) %>%
  summarize(
    var_elbill = survey_var(DOLLAREL),
    sd_elbill = survey_sd(DOLLAREL)
  )
```

# Unweighted Analysis

The unweighted() function calculates unweighted summaries from a tbl_svy object, providing the summary among the respondents without extrapolating to a population estimate. 

```{r}
recs_des %>%
  summarize(
    elec_bill = survey_mean(DOLLAREL),
    elec_unweight = unweighted(mean(DOLLAREL))
  )
```

# Subpopulation Analysis

Statistics for sub-groups.

```{r}
recs_des %>%
  filter(BTUNG > 0) %>%
  summarize(
    NG_mean = survey_mean(DOLLARNG,
      vartype = c("se", "ci")
    )
  )
```


```{r}
recs_des %>%
  summarize(
    NG_mean = survey_mean(DOLLARNG,
      vartype = c("se", "ci")
    )
  )
```

# Design Effects

The design effect measures how the precision of an estimate is influenced by the sampling design. In other words, it measures how much more or less statistically efficient the survey design is compared to a simple random sample (SRS). It is computed by taking the ratio of the estimate’s variance under the design at hand to the estimate’s variance under a simple random sample without replacement. A design effect less than 1 indicates that the design is more statistically efficient than an SRS design, which is rare but possible in a stratified sampling design where the outcome correlates with the stratification variable(s). A design effect greater than 1 indicates that the design is less statistically efficient than an SRS design.

```{r}
recs_des %>%
  summarize(across(
    c(BTUEL, BTUNG, BTULP, BTUFO, BTUWOOD),
    ~ survey_mean(.x, deff = TRUE, vartype = NULL)
  )) %>%
  select(ends_with("deff"))
```

# Summary Rows

```
cascade(
  .data, 
  ..., 
  .fill = NA, 
  .fill_level_top = FALSE, 
  .groupings = NULL
)
```

- .data: A tbl_svy object
- ...: Name-value pairs of summary functions (same as the summarize() function)
- .fill: Value to fill in for group summaries (defaults to NA)
- .fill_level_top: When filling factor variables, whether to put the value ‘.fill’ in the first position (defaults to FALSE, placing it in the bottom)

```{r}
recs_des %>%
  group_by(Region) %>%
  cascade(
    DOLLAREL_mn = survey_mean(DOLLAREL),
    .fill = "National",
    .fill_level_top = T
  )
```

# Estimates for many outcomes

Suppose we want to calculate the total and average consumption, along with coefficients of variation (CV), for each fuel type. These include the reported consumption of electricity (BTUEL), natural gas (BTUNG), liquid propane (BTULP), fuel oil (BTUFO), and wood (BTUWOOD).

```{r}
consumption_ests <- recs_des %>%
  summarize(across(
    starts_with("BTU"),
    list(
      Total = ~ survey_total(.x, vartype = "cv"),
      Mean = ~ survey_mean(.x, vartype = "cv")
    ),
    .unpack = "{outer}.{inner}"
  ))
consumption_ests
```

The estimated total consumption of electricity (BTUEL) is 4,453,284,510,065 (BTUEL_Total.coef), the estimated average consumption is 36,051 (BTUEL_Mean.coef), and the CV is 0.0038.

```{r}
consumption_ests_long <- consumption_ests %>%
  pivot_longer(
    cols = everything(),
    names_to = c("FuelType", "Stat", "Type"),
    names_pattern = "BTU(.*)_(.*)\\.(.*)"
  )
consumption_ests_long
```

```{r}
consumption_ests_long %>%
  mutate(Type = case_when(
    Type == "coef" ~ "",
    Type == "_cv" ~ " (CV)"
  )) %>%
  pivot_wider(
    id_cols = FuelType,
    names_from = c(Stat, Type),
    names_glue = "{Stat}{Type}",
    values_from = value
  )
```

## Proportions

```{r}
cool_heat_tab <- recs_des %>%
  summarize(across(c(ACUsed, SpaceHeatingUsed), ~ survey_mean(.x),
    .unpack = "{outer}.{inner}"
  ))

cool_heat_tab %>%
  pivot_longer(everything(),
    names_to = c("Comfort", ".value"),
    names_pattern = "(.*)\\.(.*)"
  ) %>%
  rename(
    p = coef, se = `_se`
  )
```

`purrr::map()`

Suppose we want to create a table that shows the proportion of people who express trust in their government (TrustGovernment)10 as well as those that trust in people (TrustPeople)11 using data from the 2020 ANES.

```{r}
calc_ps <- function(var) {
  anes_des %>%
    drop_na(!!sym(var)) %>%
    group_by(!!sym(var)) %>%
    summarize(p = survey_prop() * 100) %>%
    mutate(Variable = var) %>%
    rename(Answer := !!sym(var)) %>%
    select(Variable, everything())
}
```

```{r}
c("TrustGovernment", "TrustPeople") %>%
  map(calc_ps) %>%
  list_rbind()
```
















