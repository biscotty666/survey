---
title: "Missing Data"
format: gfm
---


```{r, setup, include=FALSE}
knitr::opts_chunk$set(paged.print = FALSE)
```


# Setup

```{r}
#| message: false
library(tidyverse)
library(survey)
library(srvyr)
library(naniar)
library(haven)
library(gt)
library(srvyrexploR)
```

```{r}
targetpop <- 231592693

anes_adjwgt <- anes_2020 %>%
  mutate(Weight = Weight / sum(Weight) * targetpop)

anes_des <- anes_adjwgt %>%
  as_survey_design(
    weights = Weight,
    strata = Stratum,
    ids = VarUnit,
    nest = TRUE
  )

recs_des <- recs_2020 %>%
  as_survey_rep(
    weights = NWEIGHT,
    repweights = NWEIGHT1:NWEIGHT60,
    type = "JK1",
    scale = 59 / 60,
    mse = TRUE
  )

book_colors <- c("#0b3954", "#087e8b", "#bfd7ea", "#ff8484", "#8d6b94")
```

There are two main categories that missing data typically fall into: missing by design and unintentional missing data. Missing by design is part of the survey plan and can be more easily incorporated into weights and analyses. Unintentional missing data, on the other hand, can lead to bias in survey estimates if not correctly accounted for. Below we provide more information on the types of missing data.

1. Missing by design/questionnaire skip logic: This type of missingness occurs when certain respondents are intentionally directed to skip specific questions based on their previous responses or characteristics. For example, in a survey about employment, if a respondent indicates that they are not employed, they may be directed to skip questions related to their job responsibilities. Additionally, some surveys randomize questions or modules so that not all participants respond to all questions. In these instances, respondents would have missing data for the modules not randomly assigned to them.

2. Unintentional missing data: This type of missingness occurs when researchers do not intend for there to be missing data on a particular question, for example, if respondents did not finish the survey or refused to answer individual questions. There are three main types of unintentional missing data that each should be considered and handled differently (Mack, Su, and Westreich 2018; Schafer and Graham 2002):

- Missing completely at random (MCAR): The missing data are unrelated to both observed and unobserved data, and the probability of being missing is the same across all cases. For example, if a respondent missed a question because they had to leave the survey early due to an emergency.
- Missing at random (MAR): The missing data are related to observed data but not unobserved data, and the probability of being missing is the same within groups. For example, we know the respondents’ ages and older respondents choose not to answer specific questions but younger respondents do answer them.
- Missing not at random (MNAR): The missing data are related to unobserved data, and the probability of being missing varies for reasons we are not measuring. For example, if respondents with depression do not answer a question about depression severity.

# Assessing missing data

```{r}
anes_2020 %>%
  select(V202051:EarlyVote2020) %>%
  summary()
```

```{r}
anes_2020 %>%
  count(VotedPres2020, V202072)
```

```{r missing-data-vis-miss}
#| message: false
anes_2020_derived <- anes_2020 %>%
  select(
    -starts_with("V2"), -CaseID, -InterviewMode,
    -Weight, -Stratum, -VarUnit
  )

anes_2020_derived %>%
  vis_miss(cluster = TRUE, show_perc = FALSE) +
  scale_fill_manual(
    values = book_colors[c(3, 1)],
    labels = c("Present", "Missing"),
    name = ""
  ) +
  theme(
    plot.margin = margin(5.5, 30, 5.5, 5.5, "pt"),
    axis.text.x = element_text(angle = 70)
  )
```

Even if we did not have the informative variable names, we could deduce that VotedPres2020, VotedPres2020_selection, and EarlyVote2020 are likely connected since their missing data patterns are similar. Additionally, we can also look at VotedPres2016_selection and see that there are a lot of missing data in that variable. The missing data are likely due to a skip pattern, and we can look at other graphics to see how they relate to other variables. 

```{r missing-data-miss-fct}
anes_2020_derived %>%
  gg_miss_fct(VotedPres2016) +
  scale_fill_gradientn(
    guide = "colorbar",
    name = "% Miss",
    colors = book_colors[c(3, 2, 1)]
  ) +
  ylab("Variable") +
  xlab("Voted for President in 2016")
```

There are other visualizations that work well with numeric data. For example, in the RECS 2020 data, we can plot two continuous variables and the missing data associated with them to see if there are any patterns in the missingness. 

```{r}
recs_2020_shadow <- bind_shadow(recs_2020)
ncol(recs_2020)
ncol(recs_2020_shadow)
```

```{r}
recs_2020_shadow %>%
  count(HeatingBehavior, HeatingBehavior_NA)
```

```{r missing-data-hist}
recs_2020_shadow %>%
  filter(TOTALDOL < 5000) %>%
  ggplot(aes(x = TOTALDOL, fill = HeatingBehavior_NA)) +
  geom_histogram() +
  scale_fill_manual(
    values = book_colors[c(3, 1)],
    labels = c("Present", "Missing"),
    name = "Heating Behavior"
  ) +
  theme_minimal() +
  xlab("Total Energy Cost (Truncated at $5000)") +
  ylab("Number of Households")
```

The distributions appear to be different, suggesting a pattern for the lack of responses.

# Analyzing Missing Data

## Recoding missing data

 Even within a variable, there can be different reasons for missing data. In publicly released data, negative values are often present to provide different meanings for values. For example, in the ANES 2020 data, they have the following negative values to represent different types of missing data:

- –9: Refused
- –8: Don’t Know
- –7: No post-election data, deleted due to incomplete interview
- –6: No post-election interview
- –5: Interview breakoff (sufficient partial IW)
- –4: Technical error
- –3: Restricted
- –2: Other missing reason (question specific)
- –1: Inapplicable


However, the {naniar} package does have the option to code special missing values. For example, if we wanted to have two NA values, one that indicated the question was missing by design (e.g., due to skip patterns) and one for the other missing categories, we can use the nabular format to incorporate these with the recode_shadow() function.

```{r}
anes_2020_shadow <- anes_2020 %>%
  select(starts_with("V2")) %>%
  mutate(across(everything(), ~ case_when(
    .x < -1 ~ NA,
    TRUE ~ .x
  ))) %>%
  bind_shadow() %>%
  recode_shadow(V201103 = .where(V201103 == -1 ~ "skip"))
anes_2020_shadow %>% count(V201103, V201103_NA)
```

## Accounting for skip patterns

One has several choices when analyzing these data which include: (1) only including those with a valid value of HeatingBehavior and specifying the universe as those with heat or (2) including those who do not have heat. It is important to specify what population an analysis generalizes to.

> Choice 1

```{r}
recs_des %>%
  filter(!is.na(HeatingBehavior)) %>%
  group_by(HeatingBehavior) %>%
  summarise(
    p = survey_prop()
  )
```

> Choice 2

```{r}
recs_des %>%
  group_by(interact(SpaceHeatingUsed, HeatingBehavior)) %>%
  summarise(
    p = survey_prop()
  )
```

If we ran the first analysis, we would say that 16.8% of households with heat use a programmable or smart thermostat for heating their home. If we used the results from the second analysis, we would say that 16% of households use a programmable or smart thermostat for heating their home. The distinction between the two statements is made bold for emphasis. Skip patterns often change the universe we are talking about and need to be carefully examined. 

Filtering to the correct universe is important when handling these types of missing data. The nabular we created above can also help with this. If we have NA_skip values in the shadow, we can make sure that we filter out all of these values and only include relevant missing values. To do this with survey data, we could first create the nabular, then create the design object on that data, and then use the shadow variables to assist with filtering the data. Let’s use the nabular we created above for ANES 2020 (anes_2020_shadow) to create the design object.

```{r}
anes_des_shadow <- anes_2020_shadow %>%
  mutate(V200010b = V200010b / sum(V200010b) * targetpop) %>%
  as_survey_design(
    weights = V200010b,
    strata = V200010d,
    ids = V200010c,
    nest = T
  )
```

Without removing any cases:

```{r}
anes_des_shadow %>%
  group_by(V201103) %>%
  summarise(
    All_Missing = survey_prop()
  )
```

Removing skip-patterns:

```{r}
anes_des_shadow %>%
  filter(V201103_NA != "NA_skip") %>%
  group_by(V201103) %>%
  summarise(
    All_Missing = survey_prop()
  )
```

Removing all missing values:

```{r}
anes_des_shadow %>%
  filter(V201103_NA == "!NA") %>%
  group_by(V201103) %>%
  summarise(
    All_Missing = survey_prop()
  )
```









